\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Algoritmo y representaci\IeC {\'o}n gr\IeC {\'a}fica del desplazamiento de las casillas de la matriz inicial. En la figura de la izquierda se muestra el algoritmo con el que se realizaron los diferentes desplazamientos para una celda gen\IeC {\'e}rica. A la derecha, en la poblaci\IeC {\'o}n inicial, la celda en amarillo permite visuaizar c\IeC {\'o}mo se desplaza una celda desde una posici\IeC {\'o}n inicial $[i_{0}, j_{0}]$, a una posici\IeC {\'o}n final $[i_{f}, j_{f}]$, donde $i , j$ representan las filas y columnas, respectivamente}}{1}{figure.1}\protected@file@percent }
\newlabel{fg:rb}{{1}{1}{Algoritmo y representación gráfica del desplazamiento de las casillas de la matriz inicial. En la figura de la izquierda se muestra el algoritmo con el que se realizaron los diferentes desplazamientos para una celda genérica. A la derecha, en la población inicial, la celda en amarillo permite visuaizar cómo se desplaza una celda desde una posición inicial $[i_{0}, j_{0}]$, a una posición final $[i_{f}, j_{f}]$, donde $i , j$ representan las filas y columnas, respectivamente}{figure.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Algoritmo para la evoluci\IeC {\'o}n de la poblaci\IeC {\'o}n inicial. Se observa c\IeC {\'o}mo mediante un ciclo $for$ anidado, se recorre la posici\IeC {\'o}n de cada celda y se compara con la matriz de estados con cuatro condiciones distintas, que son las reglas previamente establecidas para el juego. Como retorno de este bucle iterativo, se obtiene una nueva matriz cuyos elementos representan las nuevas personas vivas y muertas. }}{2}{figure.2}\protected@file@percent }
\newlabel{fg:evolution}{{2}{2}{Algoritmo para la evolución de la población inicial. Se observa cómo mediante un ciclo $for$ anidado, se recorre la posición de cada celda y se compara con la matriz de estados con cuatro condiciones distintas, que son las reglas previamente establecidas para el juego. Como retorno de este bucle iterativo, se obtiene una nueva matriz cuyos elementos representan las nuevas personas vivas y muertas}{figure.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Algoritmo para la evoluci\IeC {\'o}n entre generaciones. En la figura izquierda, se observa la poblaci\IeC {\'o}n inicial (creada mediante una matriz aleatoria), correspondiente con $\Gamma = 0$. Los puntos amarillos y morados resprentan las personas vivas y muertas de dicha distribuci\IeC {\'o}n. En la imagen derecha, se puede apreciar el resultado final luego de evoluciar 20 generaciones, cuyo resultado es una clara disminuci\IeC {\'o}n de las personas vivas. }}{3}{figure.3}\protected@file@percent }
\newlabel{fg:final}{{3}{3}{Algoritmo para la evolución entre generaciones. En la figura izquierda, se observa la población inicial (creada mediante una matriz aleatoria), correspondiente con $\Gamma = 0$. Los puntos amarillos y morados resprentan las personas vivas y muertas de dicha distribución. En la imagen derecha, se puede apreciar el resultado final luego de evoluciar 20 generaciones, cuyo resultado es una clara disminución de las personas vivas}{figure.3}{}}
